clear all
close all
% assign glomeruli

leftLobe=0;
minResponse=0.25; % remove clusters with maximum response less than this

odorWeight=1;
physDistanceWeight=1;


filename=uigetfile(); % load processed k means .mat file

load(filename)

% small change
% small change second computer
% third change
% load published odor response matrix and centroids
publishedOdorPath='/Users/mattchurgin/Desktop/dblab/mattFunctions/odorpanelResponsesDoOR/odorPanel_12/odorPanel_12_DoORData.mat';
publishedOR=load(publishedOdorPath);
pubOR=publishedOR.publishedOR.gh146response';
pubNames=publishedOR.publishedOR.gh146receptorNames;
pubGlomNames=publishedOR.publishedOR.gh146glomerulusNames;
pubX=publishedOR.publishedOR.gh146xCentroid; 
pubY=publishedOR.publishedOR.gh146yCentroid;
pubZ=publishedOR.publishedOR.gh146zCentroid;
for j=1:length(pubNames)
    pubNames{j}=num2str(pubNames{j});
    pubGlomNames{j}=num2str(pubGlomNames{j});
end

% mean center and normalize published data
% centroid data is for the right antenna lobe
for i=1:size(pubOR,2)
    if nanstd(pubOR(:,i))>0
        pubOR(:,i)=(pubOR(:,i)-nanmean(pubOR(:,i)))./nanstd(pubOR(:,i));
    else
        pubOR(:,i)=(pubOR(:,i)-nanmean(pubOR(:,i)));
    end
end

if leftLobe
    pubX=-(pubX-nanmean(pubX))/nanstd(pubX); % flip x axis centroids if looking at a left antenna lobe
else
    pubX=(pubX-nanmean(pubX))/nanstd(pubX);
end
pubY=-(pubY-nanmean(pubY))/nanstd(pubY); % minus sign flips the y centroids to match our data 
pubZ=-(pubZ-nanmean(pubZ))/nanstd(pubZ); % minus sign flips the z centroids to match our data (lower z means more ventral)

% calculate max response over all time points
maxResponse=max(grnResponseNorm,[],3);

% omit air
myOR=maxResponse(2:13,:);
todelete=max(myOR)<minResponse;
myOR(:,todelete)=NaN;
myORraw=myOR;


% load cluster centroid data and normalize
cX=zeros(1,length(clusterInfoU));
cY=zeros(1,length(clusterInfoU));
cZ=zeros(1,length(clusterInfoU));

for j=1:length(clusterInfoU)
    cX(j)=clusterInfoU{j}.Centroid(1);
    cY(j)=clusterInfoU{j}.Centroid(2);
    cZ(j)=clusterInfoU{j}.Centroid(3);
end
cX(todelete)=NaN;
cY(todelete)=NaN;
cZ(todelete)=NaN;
cX=(cX-nanmean(cX))/nanstd(cX);
cY=(cY-nanmean(cY))/nanstd(cY);
cZ=(cZ-nanmean(cZ))/nanstd(cZ);


% mean center and normalize each cluster
for i=1:size(myOR,2)
    if std(myOR(:,i))>0
        myOR(:,i)=(myOR(:,i)-mean(myOR(:,i)))./std(myOR(:,i));
    else
        myOR(:,i)=(myOR(:,i)-mean(myOR(:,i)));
    end
end

% calculate euclidean distance between each cluster and published responses
% for these odors
odorDist=NaN*zeros(size(myOR,2),size(pubOR,2));
physDist=NaN*zeros(size(myOR,2),size(pubOR,2));
for i=1:size(myOR,2)
    for j=1:size(pubOR,2)
        if any(pubOR(:,j))
            if any(myOR(:,i))
                odorDist(i,j)=sqrt(nansum((myOR(:,i)-pubOR(:,j)).^2))/sqrt(sum(isfinite(pubOR(:,j))));
                physDist(i,j)=sqrt((cX(i)-pubX(j)).^2+(cY(i)-pubY(j)).^2+(cZ(i)-pubZ(j)).^2);
            end
        end
    end
end

% normalize odorDist and physDist for equal contributions
odorDist=odorDist/max(max(odorDist));
physDist=physDist/max(max(physDist));

compositeDist=odorWeight*odorDist+physDistanceWeight*physDist;


figure
imagesc(myORraw)
xlabel('Cluster #')
ylabel('Odor #')
title('Cluster Maximum dF/F (Raw)')
set(gca,'FontSize',20)

figure
imagesc(myOR)
xlabel('Cluster #')
ylabel('Odor #')
title('Cluster Maximum dF/F (Normalized)')
set(gca,'FontSize',20)

figure
imagesc(pubOR)
set(gca,'xtick',1:length(pubNames),'xticklabel',string(pubNames),'FontSize',5)
xtickangle(30)
xlabel('Glomeruli','FontSize',20)
ylabel('Odor #','FontSize',20)
title('Glomerular Maximum Response','FontSize',20)


figure;
imagesc(odorDist)
%set(gca,'FontSize',20)
set(gca,'xtick',1:length(pubNames),'xticklabel',string(pubNames),'FontSize',5)
xtickangle(30)
xlabel('Glomeruli','FontSize',20)
ylabel('Cluster #','FontSize',20)
title('Odor Panel Response Euclidean Distance','FontSize',20)

figure;
imagesc(physDist)
%set(gca,'FontSize',20)
set(gca,'xtick',1:length(pubNames),'xticklabel',string(pubNames),'FontSize',5)
xtickangle(30)
xlabel('Glomeruli','FontSize',20)
ylabel('Cluster #','FontSize',20)
title('Physical Euclidean Distance','FontSize',20)

figure;
imagesc(log(compositeDist))
%set(gca,'FontSize',20)
set(gca,'xtick',1:length(pubNames),'xticklabel',string(pubNames),'FontSize',5)
xtickangle(30)
xlabel('Glomeruli','FontSize',20)
ylabel('Cluster #','FontSize',20)
title('Composite Distance','FontSize',20)

% find glomerulus that minimizes multiplied distance to each cluster
glomMinimizing=zeros(1,size(myOR,2));
glomMinimizingMatrix=zeros(size(myOR,2),size(pubOR,2));
for i=1:size(myOR,2)
    if any(compositeDist(i,:))
        [val ind]=nanmin(compositeDist(i,:));
        glomMinimizing(i)=ind;
        
        [asdf asdf2]=sort(compositeDist(i,:));
        glomMinimizingMatrix(i,:)=asdf2;
    else
        glomMinimizing(i)=0;
        glomMinimizingMatrix(i,:)=NaN;
    end
end

uniqueGloms=unique(glomMinimizing);

% find cluster that minimizes multiplied distance to each glomerulus
uniqueClusters=zeros(1,(length(uniqueGloms)));
for i=2:(length(uniqueGloms))
    currGlom=uniqueGloms(i);
    currClusters=find(glomMinimizing==currGlom);
    [mymin myind]=min(compositeDist(currClusters,currGlom));
    uniqueClusters(i)=currClusters(myind);
end

figure
for j=2:length(uniqueGloms)
    p2=patch(isosurface(clusterVolU{uniqueClusters(j)}),'FaceColor',rand(1,3),'EdgeColor','none','FaceAlpha',0.3);
    isonormals(clusterVolU{uniqueClusters(j)},p2)
    hold on
end
%%
% find cluster that minimizes distance to each glomeruli
for i=1:size(pubOR,2)
    if any(distM(:,i))
        [val ind]=nanmin(distM(:,i));
        clusterMinimizing(i)=ind;
    else
        clusterMinimizing(i)=0;
    end
end

pcl=unique(clusterMinimizing);

for j=2:length(pcl)
    [val ind]=min(distM(pcl(j),:));
    glomMinimizing(pcl(j))=ind;
end
%
% assign glomeruli by finding minimal distance from each cluster
for i=1:size(myOR,2)
    if sum(isfinite(distM(i,:)))>0
        [val ind]=nanmin(distM(i,:));
        clusterName{i}=pubNames{ind};
    else
        clusterName{i}='censored';
    end
end

% next steps:
% need to optimally assign glomeruli according to distances
%% try to assign each cluster to a glomerulus
alreadyTaken=[];
distMcopy=distM;
for i=1:size(pubOR,2)
    if any(distM(:,i))
        confirmi=0;
        ind=[];
        while confirmi~=i
            % find cluster with minimal distance to ith glom
            [val ind]=nanmin(distM(:,i));
            
            % find glom with minimal distance to ind cluster
            [valc confirmi]=nanmin(distM(ind,:));
        end
        
        clusterMinimizing(i)=ind;
        
    else
        clusterMinimizing(i)=0;
    end
end
%%
figure
view(3);
axis tight
camlight
lighting gouraud
hold on
for j=2:length(pcl)
    p2=patch(isosurface(clusterVols{pcl(j)}),'FaceColor',rand(1,3),'EdgeColor','none','FaceAlpha',0.25);
    isonormals(clusterVols{pcl(j)},p2)
end

% for j=1:length(clusterVols)
%     if ~todelete(j)
%         p2=patch(isosurface(clusterVols{j}),'FaceColor',rand(1,3),'EdgeColor','none','FaceAlpha',0.5);
%         isonormals(clusterVols{j},p2)
%     end
%     %drawnow
%     %pause
% end